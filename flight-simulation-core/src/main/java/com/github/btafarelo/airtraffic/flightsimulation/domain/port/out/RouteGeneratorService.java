package com.github.btafarelo.airtraffic.flightsimulation.domain.port.out;

import com.github.btafarelo.airtraffic.flightsimulation.domain.model.Airport;
import com.github.btafarelo.airtraffic.flightsimulation.domain.model.FlightPosition;
import com.github.btafarelo.airtraffic.flightsimulation.domain.model.FlightRoute;
import com.github.btafarelo.airtraffic.flightsimulation.domain.port.out.util.GeoUtils;

import java.util.Random;

import static com.github.btafarelo.airtraffic.flightsimulation.domain.Config.*;

class RouteGeneratorService {

    private final Random random;

    private final double ANGLE_RANGE_72 = 0.4 * Math.PI; // 72 degrees
    private static final double FULL_CIRCLE_RADIANS = 2 * Math.PI;
    private static final double FULL_AND_HALF_CIRCLE_RADIANS = 3 * Math.PI;

    private static final FlightPosition OUT_OF_RANGE = new FlightPosition(
            0.0,0.0,0.0,false,0.0,0.0);

    RouteGeneratorService() {
        this.random = new Random();
    }

    FlightRoute generateRoute(Airport origin, Airport destination) {
        double[] startPoint;
        double[] endPoint;

        if (origin == Airport.GENEVA) {
            startPoint = new double[]{ RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE };

            double endAngle = random.nextDouble() * FULL_CIRCLE_RADIANS;

            endPoint = GeoUtils.getCoordinatesAtDistance(RADAR_CENTER_LATITUDE,
                    RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, endAngle);
        } else if (destination == Airport.GENEVA) {
            double startAngle = random.nextDouble() * FULL_CIRCLE_RADIANS;

            startPoint = GeoUtils.getCoordinatesAtDistance(RADAR_CENTER_LATITUDE,
                    RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, startAngle);

            endPoint = new double[]{ RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE };
        } else {
            // Transit flight - start and end at radar perimeter edges
            double startAngle = random.nextDouble() * FULL_CIRCLE_RADIANS;

            startPoint = GeoUtils.getCoordinatesAtDistance(RADAR_CENTER_LATITUDE,
                    RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, startAngle);

            // Generate end point on opposite side of radar perimeter
            // The -0.5 in the expression (random.nextDouble() - 0.5)
            // is used to shift the range of the random number generated by random.nextDouble()
            double endAngle = startAngle + Math.PI + (random.nextDouble() - 0.5) * ANGLE_RANGE_72;

            endPoint = GeoUtils.getCoordinatesAtDistance(
                    RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, endAngle);
        }

        FlightRoute flightRoute = new FlightRoute(startPoint[0], startPoint[1], endPoint[0], endPoint[1],
                origin, destination);

        generateFullRoute(flightRoute);

        return flightRoute;
    }

    void generateFullRoute(FlightRoute route) {

        int totalUpdates = FLIGHT_DURATION_SECONDS * 1000 / FLIGHT_UPDATE_INTERVAL_MS;

        long startTime = System.currentTimeMillis();

        double altitude = 10000;//flightUtils.generateAltitude();
        double speed = 100; //flightTrackData.getSpeed();

        for (int step = 0; step <= totalUpdates; step++) {
            double progress = (double) step / totalUpdates;
            double latitude = route.getStartLat() + (route.getEndLat() - route.getStartLat()) * progress;
            double longitude = route.getStartLon() + (route.getEndLon() - route.getStartLon()) * progress;

            // Calculate distance from radar center
            double distanceFromRadar = GeoUtils.calculateDistance(RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE,
                    latitude, longitude
            );

            boolean inRadarRange = distanceFromRadar <= RADAR_PERIMETER_DISTANCE_KM;

            // Add realistic variations
            double altitudeVariation = Math.sin(progress * FULL_CIRCLE_RADIANS) * AIRCRAFT_ALTITUDE_VARIATION;
            double currentAltitude = altitude + altitudeVariation;

            double speedVariation = Math.sin(progress * FULL_AND_HALF_CIRCLE_RADIANS) * AIRCRAFT_SPEED_VARIATION;
            double currentSpeed = speed + speedVariation;

            route.addStep(new FlightPosition(latitude, longitude, distanceFromRadar, inRadarRange, currentAltitude,
                    currentSpeed));
        }

        route.addStep(OUT_OF_RANGE);
    }
}
