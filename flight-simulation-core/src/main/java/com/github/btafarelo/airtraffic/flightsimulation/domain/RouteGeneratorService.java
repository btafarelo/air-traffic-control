package com.github.btafarelo.airtraffic.flightsimulation.domain;

import com.github.btafarelo.airtraffic.flightsimulation.domain.model.Airport;
import com.github.btafarelo.airtraffic.flightsimulation.domain.model.FlightPosition;
import com.github.btafarelo.airtraffic.flightsimulation.domain.model.FlightRoute;

import java.util.Random;

import static com.github.btafarelo.airtraffic.flightsimulation.domain.Config.*;

class RouteGeneratorService {

    private final Random random;

    private final double ANGLE_RANGE_72 = 0.4 * Math.PI; // 72 degrees
    private static final double FULL_CIRCLE_RADIANS = 2 * Math.PI;
    private static final double FULL_AND_HALF_CIRCLE_RADIANS = 3 * Math.PI;
    private static final double RADIANS_TO_DEGREES = 180.0 / Math.PI;
    private static final double DEGREES_TO_RADIANS = Math.PI / 180.0;

    private static final FlightPosition OUT_OF_RANGE = new FlightPosition(
            0.0,0.0,0.0,false,0.0,0.0);

    RouteGeneratorService() {
        this.random = new Random();
    }

    FlightRoute generateRoute(Airport origin, Airport destination) {
        double[] startPoint;
        double[] endPoint;

        if (origin == Airport.GENEVA) {
            startPoint = new double[]{ RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE };

            double endAngle = random.nextDouble() * FULL_CIRCLE_RADIANS;

            endPoint = getCoordinatesAtDistance(RADAR_CENTER_LATITUDE,
                    RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, endAngle);
        } else if (destination == Airport.GENEVA) {
            double startAngle = random.nextDouble() * FULL_CIRCLE_RADIANS;

            startPoint = getCoordinatesAtDistance(RADAR_CENTER_LATITUDE,
                    RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, startAngle);

            endPoint = new double[]{ RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE };
        } else {
            // Transit flight - start and end at radar perimeter edges
            double startAngle = random.nextDouble() * FULL_CIRCLE_RADIANS;

            startPoint = getCoordinatesAtDistance(RADAR_CENTER_LATITUDE,
                    RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, startAngle);

            // Generate end point on opposite side of radar perimeter
            // The -0.5 in the expression (random.nextDouble() - 0.5)
            // is used to shift the range of the random number generated by random.nextDouble()
            double endAngle = startAngle + Math.PI + (random.nextDouble() - 0.5) * ANGLE_RANGE_72;

            endPoint = getCoordinatesAtDistance(
                    RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE, RADAR_PERIMETER_DISTANCE_KM, endAngle);
        }

        FlightRoute flightRoute = new FlightRoute(startPoint[0], startPoint[1], endPoint[0], endPoint[1],
                calculateDistance(startPoint[0], startPoint[1], endPoint[0], endPoint[1]),
                origin, destination);

        generateFullRoute(flightRoute);

        return flightRoute;
    }

    void generateFullRoute(FlightRoute route) {

        int totalUpdates = FLIGHT_DURATION_SECONDS * 1000 / FLIGHT_UPDATE_INTERVAL_MS;

        long startTime = System.currentTimeMillis();

        double altitude = 10000;//flightUtils.generateAltitude();
        double speed = 100; //flightTrackData.getSpeed();

        for (int step = 0; step <= totalUpdates; step++) {
            double progress = (double) step / totalUpdates;
            double latitude = route.getStartLat() + (route.getEndLat() - route.getStartLat()) * progress;
            double longitude = route.getStartLon() + (route.getEndLon() - route.getStartLon()) * progress;

            // Calculate distance from radar center
            double distanceFromRadar = calculateDistance(RADAR_CENTER_LATITUDE, RADAR_CENTER_LONGITUDE,
                    latitude, longitude
            );

            boolean inRadarRange = distanceFromRadar <= RADAR_PERIMETER_DISTANCE_KM;

            // Add realistic variations
            double altitudeVariation = Math.sin(progress * FULL_CIRCLE_RADIANS) * AIRCRAFT_ALTITUDE_VARIATION;
            double currentAltitude = altitude + altitudeVariation;

            double speedVariation = Math.sin(progress * FULL_AND_HALF_CIRCLE_RADIANS) * AIRCRAFT_SPEED_VARIATION;
            double currentSpeed = speed + speedVariation;

            route.addStep(new FlightPosition(latitude, longitude, distanceFromRadar, inRadarRange, currentAltitude,
                    currentSpeed));
        }

        route.addStep(OUT_OF_RANGE);
    }

    private static double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        double a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                        Math.sin(dLon/2) * Math.sin(dLon/2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return EARTH_RADIUS_KM * c;
    }

    private static double[] getCoordinatesAtDistance(double centerLat, double centerLon,
                                                    double distance, double angle) {

        double latOffset = distance / EARTH_RADIUS_KM * RADIANS_TO_DEGREES;
        double lonOffset = distance / EARTH_RADIUS_KM * Math.cos(centerLat * DEGREES_TO_RADIANS) * RADIANS_TO_DEGREES;

        double newLat = centerLat + latOffset * Math.sin(angle);
        double newLon = centerLon + lonOffset * Math.cos(angle);

        return new double[]{newLat, newLon};
    }
}
